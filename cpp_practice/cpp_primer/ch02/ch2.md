## 数据类型
### 基本内置类型：
1. 算术类型 
2. 空类型

**当给一种类型对象强行赋了另一种类型的值时：有两点需要注意** 

(1). 当给无符号类型赋予一个超出它表示范围值的时候，结果是，这个值对无符号类型表示数值总数取模得到的值。

(2). 给一个有符号类型一个超出它范围的值，结果是无定义。

数值取模运算这里需要注意一下：负数是除数时，取模运算和求余不同。商要向负无穷取整。

### 字面值常量
(1) 整型字面值常量

(2) 字符和字符串字面值常量

如果两个字符串字面值常量紧邻，且仅有空格、缩进和换行符分隔，则它们实际上是一个整体。

(3) 转移序列

泛化的转义序列：其形式是\x后紧跟1个或多个十六进制数，或者\后紧跟1个、2个或3个八进制数。

### 布尔字面值和指针字面值
(1) 布尔字面值：true、false

(2) 指针字面值：nullptr

## 变量
变量提供一个具名的，可供操作的存储空间。

### 初始化
初始化不是赋值。
1. 列表初始化
2. 默认初始化

建议初始化每一个内置类型的变量。

### 变量声明和定义的关系
C++支持分离式编译，因此将声明和定义区分开来。
1. 声明：在变量名前添加关键字extern，而且不要显示地初始化变量。如果变量赋一个初始值，就不再是声明，而变成了定义。
    ```
    extern int i; // 声明
    extern double pi = 3.14159 // 定义
    ```

    ***在函数体内部***，如果试图初始化一个有extern关键字标记的变量，将引发错误。
    变量能且只能***被定义一次***，但是可以被多次声明。

2. 定义：
3. 标识符：C++标识符由字母、数字和下划线组成，其中必须以字母或者下划线开头。长度没有限制，但是对大小写敏感。

    ***注意***：用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头(C++为标准库保留了一些名字)。还有，定义在函数体外的标识符不能以下划线开头。

4. 作用域：

    需要注意嵌套作用域中变量的定义的覆盖和使用。
    ```
    #include <iostream>
    //这里只用于说明，函数内部不宜定义与全局变量同名的新变量
    int reused = 42; // reused有全局作用域
    int main() {
        int unique = 0; // unique有块作用域
        int reused = 2; // 新建局部变量reused，覆盖了全局变量reused
        // ::reused 是显示调用全局变量
        // 输出：42 2 0
        std::cout << ::reused << " " << reused << " " << uniqe << std::endl;
        return 0;
    }
    ```

### 复合类型
复合类型：指基于其他类型定义的类型。C++语言有几种复合类型。

1. 引用
    * 引用(左值引用)：为对象起了另外一个名字。
    * 引用必须被初始化：因为引用无法被重新绑定给其他对象。
    * 引用及别名。
    * 不能定义引用的引用：因为引用本身不是对象。
    * 引用不能与字面值和表达式计算结果绑定。
    * 引用类型必须和绑定对象的类型严格匹配。
    * ***例外***：
        1. 初始化常量引用时允许用任意表达式作为初始值，只要该表达式能够转成引用的类型即可。尤其，允许一个常量引用绑定为常量的对象、字面值、表达式。
        2. 

2. 指针
    * 指针本身就是对象
    * 如果指针没有被初始化，将有一个不确定的值
    * 指针存放的是某个对象的地址
    * 指针值：
        1. 指向一个对象
        2. 指向紧邻对象所占空间的下一个位置
        3. 空指针
        4. 无效指针（以上三种情况以外的其他值）
    * 指针的类型都要和它所指向的对象严格匹配。
        1. 例外1：允许一个指向常量的指针指向一个非常量对象。
        2. 例外2：
    * 不能把int变量直接赋值给指针。
    * 两个指针存放的地址相同（两个指针相等）有三种可能：
        它们都为空，
        都指向同一个对象，
        都指向同一个对象的下一地址。
    * void* 指针：
        
        可以存放任意类型的对象的地址。它只是指向内存空间，但是无法操作指向的内存空间的对象，因为它不知道对象是什么类型。

    ***某些有多重含义的符号***：*和&

3. 理解复合类型的声明

    基本类型和一组声明符
    * 一个类型定义多个变量时：
        ```
        int* p, i, &r = i; // p是int指针，i是整型，r是int引用
        ```
    * 对于复杂的定义，从变量名往左解读：
        ```
        int *p = nullptr;
        int *&i = p; // i是一个引用，一个指针的引用，一个int型指针的引用。(从左往右解读)
        ```

4. const 限定符
    * 对const的引用

    * 指针和const

        **指向常量的指针**
        1. 指向常量的指针不能用于改变其所指对象的值。
        2. 存放常量对象的地址，只能使用指向常量的指针。
        3. 允许一个指向常量的指针，可以指向一个非常量对象。

        **const指针**
        
        指针是对象，所以可以定义常量指针(const指针)。不变的是指针本身(指向的地址)，而不是指向的那个值。
        1. 定义方法：
        ```
        int errNumb = 0;
        int *const curErr = &errNumb;

        const double pi = 3.14;
        const double *const pip = &pi;
        ```
        2. 读懂的方法：从右往左读。

    * 顶层const、底层const

        对于指针：
        1. 顶层const：表示指针本身是个常量
        2. 底层const：表示指针所指的对象是一个常量。

        更一般的：
        1. 顶层const：表示任意对象是常量
        2. 底层const：则与指针和引用等符合类型的基本类型部分有关。

    * constexpr和常量表达式
        1. 常量表达式：指值不会改变并且在编译过程就能得到计算结果的表达式。

            字面值属于常量表达式。

            用常量表达式初始化的const对象也是常量表达式。

        2. constexpr变量
        3. 字面值类型：
            1) 算术类型、引用和指针。
            2) ...

### 处理类型
1. 类型别名 ***这块很容易错***
    * typedef
    ```
    typedef char *pstring; // 指向char类型的指针
    const pstring cstr = 0; // cstr是一个常量指针，指向的是char类型
    const pstring *ps;
    ```
    * 别名声明:
    ` using SI = Sales_item; `

2. auto类型说明
    * auto定义的变量必须有初始值。
    * auto可以声明多个变量。
    * 复合类型、常量和auto
        1. auto一般会忽略顶层const，底层const会保留下来
        2. 如果希望推断出的auto类型是一个顶层const，需要明确指明 ` const auto f = ci;`
        3. 将引用的类型设为auto：**初始值的顶层常量属性仍然保留**

        **符号*和&只是从属于某一个声明符，而非基本数据类型的一部分**，因此"auto"在一条语句中定义多个变量，初始值必须是同一种类型。
    * decltype类型指示符
        1. decltype处理顶层const和引用的方式：包括顶层const和引用。
            ```
            const int ci = 0, &cj = ci;
            decltype(ci) x = 0;
            decltype(cj) y = x; // y是const int&
            decltype(cj) z;     // 错误：引用必须初始化
            ```
        2. 如果decltype的内容是解引用操作，则decltype将得到引用类型
            ```
            int i = 42, *p = &i, &r = i;
            decltype(r + 0) b; // 正确
            decltype(*p) c; // 错误：因为是引用类型
            ```
        3. 对于decltype所用的表达式来说，如果变量名用括号括起来(一层或多层)，编译器会把变量当成一个表达式，按照引用处理。因为变量是可以作为赋值语句左值的特殊表达式。
        ***这也就是说表达式i=x的类型是&int***
        ```
        decltype(i) d;
        decltype((i)) e; // 错误：是引用类型，需要初始化
        ```

### 自定义数据结构
### 预处理器
* 头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。
* 预处理器是在编译之前执行的一段程序。
* 预处理变量无视C++语言中关于作用域的规则
1. `#include`：预处理器会在遇到`#include`就会用指定的头文件内容代替`#include`。
2. 头文件保护符：它依赖于预处理变量。
    * 预处理变量有两个状态：已定义&未定义。
    * `#define`把只有个名字设定为预处理变量。
    * `#ifdef`当且仅当变量已定义时为真。
    * `#ifndef`当且仅当变量未定义是为真。
    * 一旦检查结果为真，则执行后续操作直至遇到`#endif`。